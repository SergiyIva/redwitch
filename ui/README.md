### [Наш сайт](https://www.finevideo.ru/)
## Клиентская часть приложения Finevideo.

Finevideo - это ресурс, предоставляющий web-витрину с различными услугами по монтированию и 
обработки видео. Данный ресурс работает на основе стека MERN. Клиентская часть реализована
с использованием следующих технологий: Apollo, GraphQL, React, Bootstrap, TypeScript.


Ниже приведена документация проекта с конкретными примерами кода из проекта.

## Основная схема приложения

Клиентская часть приложения Finevideo построена на основе следующей схемы:

- **React приложение**: Как и все приложения React данное начинается с файла `index.tsx`, в котором используются строгий режим React'а, 
граница ошибок (для их перехвата) и точка входа - компонент App. Также тут импортируются стили `bootstrap.css` и `style.css`.
> **Важное замечание!**
> В папку проекта `/public` также добавлен файл скриптов `bootstrap.js`, необходимый
> для корректного выполнения библиотеки `Bootstrap`. 
- **Точка входа `App.tsx`**: В данной компоненте настраивается подключение к серверной части для обработки всех исходящих запросов приложения.
Каждый запрос включает загаловок авторизации установленный так:
```ts
import { ApolloLink } from "@apollo/client";

const authLink = new ApolloLink((operation, forward) => {
  operation.setContext((context: any) => ({
    headers: {
      ...context.headers,
      authorization:
        localStorage.getItem("token") || sessionStorage.getItem("token") || ""
    }
  }));
  return forward(operation);
});
```
`"token"` - JWT-токен установленный при прохождении авторизации на сайте.

Инициализация клиента Apollo включает в себя `link` ссылку на API, `cache` файл, устанавливающий правила кэширования получаемых данных, 
`typeDefs` схема GraphQL и соответствующие типы TypeScript и подключает инструменты разработки.
- **Маршрутизация**: Мы используем `react-router-dom` для маршрутизации во всем приложении. Маршруты
прописаны в компоненте `Main.tsx`, в котором почти все данные импортируются "лениво" и их загрузка обрабатывается
компонентом `Suspense`.  

Далее будет приведен подробный пример внедрения новой функциональности в приложение. 

## Добавление функционала
### Запрос данных
Чтобы добавить запрос данных:

* На основании схемы GraphQL из файла `typeDefs.ts` добавляем запрос в
`Query.ts`.
* Реализуем компоненту, выполняющую запрос данных.
* Добавляем логику запроса в созданную компоненту.

Теперь подробнее и с примерами.

Реализуем запрос цитаты из API. Для этого смотрим на схему в `typeDefs.ts`:
```
  type Cite {
    id: ID!
    content: String
    random: Int
  }
  type Query {
    ...
    getRandomCite: Cite!
  }
```
Также нам потребуются типы для полученных данных, поэтому в этом же файле указываем их
и экспортируем:
```ts
export type Cite = {
  id: string
  content: string
  random: number
};
``` 
Переходим в файл `Query.ts`, добавляем типы для запроса и также экспортируем:
```
import { Cite } from "./typeDefs";

export type GetRandomCite = {
  getRandomCite: Cite
}
```
Имя объекта данных (имя ключа в объекте типа, `getRandomCite` в данном случае) должно 
соответствовать имени запроса в схеме. 

Ниже добавляем сам запрос и экспортируем:
```
const GET_RANDOM_CITE = gql`
  query GetRandomCite {
    getRandomCite {
        id
        content
    }
  }
`;
export { GET_RANDOM_CITE };
```
Рассмотрим запрос подробнее. Все запросы являются переменными, имя записывается заглавными буквами
с использование snake_case, строкой запроса gql, в которых указывается тип запросы `query`,
название запросы `GetRandomCite` (с заглавной буквы). В теле запроса указывается название из
схемы и в скобках все необходимые данные (выборочно, только требуемые). На этом первый этап
добавления функциональности закончен. 

Теперь создадим компоненту, использующую новый запрос. Для этого добавим папку `Cite` с одноименным
файлом `Cite.tsx` в папку `Pages/About` соответствующей страницы.
```tsx
export const Cite = () => {
  return (
    <div className="pt-3 text-center">
      <h5>Мы сегодня говорим тебе:</h5>
      <blockquote className="blockquote mx-4 pt-3">
        <p>
        {/*  TODO тут будет текст цитаты*/}
        </p>
        <footer className="blockquote-footer">
          Немного мудрости от <cite title="Source Title">Finevideo</cite>
        </footer>
      </blockquote>
    </div>
  );
};
```
Данная компонента пока только возвращает jsx разметку, большинство стилей взято из библиотеки
Bootstrap.

Наконец, можно добавить логику запроса в компоненту, для этого мы будем использовать хук
Apollo `useQuery()`, который возвращает объект содержащий `data` объект данных, `loading`
Булево значение, указывающее на то, происходит ли загрузка данных или нет, и `error` объект 
ошибки, если она есть. Все три ключа нужно обработать.
```tsx
import { useQuery } from "@apollo/client";
import { GET_RANDOM_CITE, GetRandomCite } from "../../../../GraphQL/Query";
import { Spinner } from "../../../../Components/Spinner";

export const Cite = () => {
  const { data, loading, error } = useQuery<GetRandomCite>(GET_RANDOM_CITE);
  if (loading) return <Spinner />;
  if (error) return <div>{error.message}</div>;
  return (
      // ...
      <blockquote className="blockquote mx-4 pt-3">
        {data ? (
          <p key={data.getRandomCite.id}>{data.getRandomCite.content}</p>
        ) : (
          <p>У нас кончились цитаты, приходите позже.</p>
        )}
      // ...
      </blockquote>
  );
};
```
Как видно из примера, мы обрабатываем каждое возможное состояние в отдельности, отображая `Spinner` при загрузке,
выводя сообщение об ошибке при ее наличии и только после данные, если они имеются.

## Разработчики

- [Сергей Иванов](https://github.com/sergeyivanov/)

## Who is Nailnet?

Nailnet - это IT-компания, специализирующаяся на Web-технологиях, предлагающая широкий спектр услуг как
корпоративным, так и частным клиентам. 
